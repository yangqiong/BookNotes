堆内存为什么会有限制，如果1.5GB的垃圾回收堆内存，所需要的时间太长，可能导致应用性能和响应急剧下降。

V8的堆内存分为新生代内存空间和老生代内存空间。

## 新生代内存空间

新生代内存空间通过Scavenge算法来进行垃圾回收，而具体实现采用了Chenery算法。

Chenery算法是一种采用复制方式实现的垃圾回收算法。它将堆内存一份为二，只有一份处于使用中，一份处于限制状态。使用状态的空间称为From空间，限制状态的空间称为To空间。

当我们分配对象时，现在From空间进行分配。当开始进行垃圾回首时，会检查From空间的存货对象，这些存活对象将被复制到To空间。而非存活对象的空间将被释放。完成复制后，From空间与To空间的角色发生对换。

缺点只能使用堆内存空间的一半，但时间效率上有优异表现，**因为活对象只占新生代中较小部分**。

## 晋升

当一个对象经过多次复制依然存活时，它将被认为是生命周期较长的对象。这种对象随后会被转移到老生代，这个过程称为晋升。

在V8上有两种情况

* 对象是否经历过Scavenge回收，如果经历过一次了，会将对象从From空间复制到老生代空间，如果没有，则复制到To空间
* 当要从From空间复制一个对象到To空间时，如果To空间已经使用了超过25%，则这个对象直接晋升到老生代空间。

## 老生代内存空间

采用Mark-Sweep & Mark-Compact算法

Mark-Sweep算法是标记清除的意思，分为标记和清除两个阶段。在标记阶段遍历堆中所有对象，并标记活着的对象，在随后的清除中只清除没有被标记的对象。（**死对象在老生代中占较小部分**）

Mark-Sweep最大的问题是在进行一次标记清除回收后，内存出现不连续的状态，可能出现无法分配大对象的情况，从而提取触发再次垃圾回收。

为了解决Mark-Sweep的内存碎片问题，从而引入Mark-Compact，是标记整理的意思。主要区别是在对象在标记为死亡后，在整理的过程中，将活着的对象往一段移动，移动完成后，直接清理掉边界外的内存。

V8在回收策略中两者是结合使用的。由于Mark-Compact需要移动对象，所以它的执行速度不可能很快，所以在取舍上，V8主要使用Mark-Sweep，在空间不足以对新生代晋升过来的对象进行分配时才使用Mark-Compact。

